# Day 1 C++简介

支持三种程序设计方式

过程化程序设计、面向对象程序设计、泛型程序设计

## 过程化程序设计

**数据+算法**

明确计算机处理数据的详细过程

用程序设计语言描述处理过程

**缺点**

由于程序规模的扩大，造成程序的混乱难以确保程序的正确性

**结构化程序设计方法**

自顶向下的设计

规定程序结构只能有3种：顺序、分支、循环

## 面向对象程序设计

试图让语言满足问题的要求

设计与问题本质相对应的数据类型

**过程**：设计类——明确表示程序要处理的内容及操作，如：直线、圆、圆片

​		   使用类——设计使用类对象的程序

**优点**

使编程更加方便、**代码重写**

## 泛型程序设计

独立于特定类型的编程

**用途**

提供执行常见任务的通用工具

包括泛型的函数和类

# Day 2 程序生成

## 创建源代码文件

**源代码文件**

也称为源文件，保存程序员写好的程序，源文件的后缀名表明这是一个C++源文件，常用的有cpp

**创建源代码文件**

把写好的程序输入到计算机，并保存成一个文件

## 编译与链接

**从源文件生成可执行文件的过程**

编译：将源文件翻译成机器语言，称目标文件

链接：将目标文件与库文件的目标文件捆绑起来，形成可执行文件

编译链接方式取决于所用的操作系统和编译器

windows + gcc

```shell
gcc prog.cpp
```

PS：跟着打着玩的时候遇到的问题

“error LNK1169: 找到一个或多个多重定义的符号”

A.h中声明了变量a（非类成员)变量），A.cpp是A.h中所声明的类的实现源代码，B.cpp是主程序文件，包含头文件 A.h。编译能够通过这是因为B.cpp包含头文件 A.h后，相当于又定义了变量a。

**解决方法**

是在A.h中的变量声明前加上extern 关键字，表示这里只是声明不定义，然后在A.cpp中不加extern关键字定义这个变量，编译链接顺利通过。

# Day 3 进入C++

## 基本语法

### C++中的分号&语句块

在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

因为C++ 不以行末作为结束符的标识，所以可以在一行上放置多个语句。例如：

```C++
x = y;
y = y+1;
add(x, y);
```

等同于

```C++
x = y; y = y+1; add(x, y);
```

### **C++标识符**

C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内不允许出现标点字符，比如 @、& 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。

### C++关键字

这些保留字不能作为常量名、变量名或其他标识符名称

| asm          | else      | new              | this     |
| ------------ | --------- | ---------------- | -------- |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |

### 三字符组

三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。

三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

| ??=  | #    |
| ---- | ---- |
| ??/  | \    |
| ??'  | ^    |
| ??(  | [    |
| ??)  | ]    |
| ??!  | \|   |
| ??<  | {    |
| ??>  | }    |
| ??-  | ~    |

PS:如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

C++中的空格

只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。

在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```c++
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```c++
fruit = apples + oranges;   // 获取水果的总数
```

## Hello C++

```c++
#include <iostream>//预处理指令
int main()//函数头
{
	using namespace std;	//名字空间声明
	cout << "Come up and C++ me some time.";//显示消息 
	cout << endl;
	cout << "You will not regret it" << endl;
	return 0;//函数结束
}
```

防止窗口闪一下就关闭的代码

```C++
cout << "Press any key to continue." <<endl
cin.get();
```

那么这里看到了

```C++
cin.get();
```

### **读取字符**

一共有三种使用方法

1、用来获取输入的第一个字符

```c++
char ch;
ch = cin.get();//或cin.get(ch);
cout << ch;//若输入abc则输出a
```

2、cin.get(字符数组名,输入字符串的个数)，可以读取空格

```C++
char arr[20];
cin.get(arr,20);
cout << arr;//只会输出19个元素，最后一个为终止符'\0'
```

3、cin.get()用于舍弃输入流的不需要的字符(例如回车)

```C++
char a[10];
char b[10];
cin.get(a,10);
cin.get(b,10);
cout << a << " " << b;
```

cin.get（）是不会舍弃行尾的换行符的
也就是说如果你是输入a后回车在输入b你会发现你不能输入b程序就输出结束了
或者你输入a后空格在输入b，a是从行头开始取，去满在下一个b
这里与cin.getline()不一样，cin.getline(是丢弃行尾的换行符的)
这里就可以用cin.get()还去除换行符

因此上面的代码可以改成

```C++
char a[10];
char b[10];
cin.get(a,10);
cin.get();//去除a输入完毕后的回车
cin.get(b,10);
cout << a << " " << b;
```

同样读取空格等特殊字符的方法也有

```C++
getchar()
```

但是建议使用cin.get()，效率高

那么顺便学一下

### **读取字符数组**

```c++
cin.getline(字符数组，接收个数，结束字符)
```

- 可以接收空格等；
- 结束符可以通过设置第三个参数自己设置，默认是回车

那么再顺便学一下

### **读取String**·

```C++
getline(cin, s);
```

### **预处理指令**

预处理指令以#开头

编译时先处理预处理指令，再进行编译

```C++
#include <iostream>//在此插入文件iosteam的内容
```

iostream被称为头文件或包含文件

### **头文件**

每个头文件支持一组工具

iostream提供输入输出的工具，如用cout输出

C风格或者C++就是风格的头文件后缀为.h

新式风格的头文件不需要后缀

C语言的头文件在文件名前加字母C

## 注释

程序的注释是解释性语句，可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种

- **//** - 一般用于单行注释。
- /*** ... \*/** - 一般用于多行注释。

C++ 注释以 **/\*** 开始，以 ***/** 终止。例如：

```C++
#include <iostream>
using namespace std;
 
int main() {
    /* 这是注释 */
 
    /* C++ 注释也可以
     * 跨行
     */ 
    cout << "Hello World!";
    return 0;
}
```

在 **/\*** 和 ***/** 注释内部，**//** 字符没有特殊的含义。在 **//** 注释内，**/\*** 和 ***/** 字符也没有特殊的含义。因此，也可以在一种注释内嵌套另一种注释。例如：

```c++
/* 用于输出 Hello World 的注释
 
cout << "Hello World"; // 输出 Hello World
 
*/
```

B!U!T!

块注释符（/*...*/）是不可以嵌套使用的。

**#if 0 ... #endif** 属于条件编译，0 即为参数。

此外，我们还可以使用 **#if 0 ... #endif** 来实现注释，且可以实现嵌套，格式为：

```c++
#if 0
   code
#endif 
```

可以把 **#if 0** 改成 **#if 1** 来执行 **code** 的代码。

这种形式对程序调试也可以帮助，测试时使用 **#if 1** 来执行测试代码，发布后使用 **#if 0** 来屏蔽测试代码。

**#if** 后可以是任意的条件语句。

下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。

```C++
#if condition
  code1
#else
  code2
#endif
```



# Day 4 C++数据类型

## 基本的内置类型

| 布尔型   | bool    |
| -------- | ------- |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

PS:很久很久以前，宽字符型（whcar_t）=unsigned short

注意：不同系统会有所差异，一字节为 8 位

再次注意：默认情况下，int、short、long都是带符号的，即 signed

再再次注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节

| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| ------------------ | ------------- | ------------------------------------------------------------ |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

在项目Day2中可查到如何查看本机的各数据类型占用字节

那么我们学到了endl这个东西

**endl**，这将在每一行后插入一个换行符，

**<<** 运算符用于向屏幕传多个值，

**sizeof()** 运算符用来获取各种数据类型的大小。

## **typedef**声明

这里也可以用typedef为一个已有的类型取一个新的名字

比如

```C++
typedef int feet;
```

我告诉编译器feet 是 int 的另一个名称

然后

```C++
feet distance;
```

我就创建了一个整形变量distance，(*＞◡❛)

## 枚举类型

枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合

如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"

```c++
enum color { red, green, blue } c;
c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5

```
enum color { red, green=5, blue };
```

在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0

# **Day 5 C++变量**

以下几种为基本变量类型

| bool    | 存储值 true 或 false。                                       |
| ------- | ------------------------------------------------------------ |
| char    | 通常是一个字符（八位）。这是一个整数类型。                   |
| int     | 对机器而言，整数的最自然的大小。                             |
| float   | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double  | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void    | 表示类型的缺失。                                             |
| wchar_t | 宽字符类型。                                                 |

同样，C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等

##  C++中的变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储

![cpp-variable-types-2020-12-14](E:\I really didn't study\C\cpp-variable-types-2020-12-14.png)

变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表

比如

```c++
type variable_list;
```

在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明

```C++
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

BUT

变量只允许定义一次，但可以在多个文件中声明

比如

## C++中的变量声明

声明变量要在头部声明哦~

but它们是在主函数内被定义和初始化的

详见C-Training-Day3

同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行

```C++
// 函数声明
int func();
 
int main()
{
    // 函数调用
    int i = func();
}
 
// 函数定义
int func()
{
    return 0;
}
```

## C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面有两个语句：

```C++
int g = 20;//√
10=20；//×
```

变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。

**自动转换规则：**

- 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
- 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。   a、若两种类型的字节数不同，转换成字节数高的类型   b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
- 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
- char型和short型参与运算时，必须先转换成int型。
- 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:

```C++
int a=1;
double b=2.5;
a=b;
cout << a; //输出为 2，丢失小数部分
```

```c++
int a = 1;
double b = 2.1;
cout << "a + b = " << a + b << endl;  //输出为a + b = 3.1
```

**强制转换规则：**

强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式）其功能是把表达式的运算结果强制转换成类型说明符所表示的类型

```C++
int a = 1;
double b = 2.1;
cout << "a + b = " << a + (int)b << endl;  //输出为a + b = 3
```

## C++ 变量作用域

作用域是程序的一个区域，一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为局部变量。
- 在函数参数的定义中声明的变量，称为形式参数。
- 在所有函数外部声明的变量，称为全局变量。

比如这部分代码就使用了

### 局部变量

在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用

```C++
#include <iostream>
using namespace std;
 
int main ()
{
  // 局部变量声明
  int a, b;
  int c;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;
}
```

### 全局变量

在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。

全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的

那么下面这串代码就使用了**全局变量**

```C++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;
}
```

Although在程序中，局部变量和全局变量的名称可以相同

在函数内，局部变量的值会覆盖全局变量的值

那我们看看这段代码

```C++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g = 20;
 
int main ()
{
  // 局部变量声明
  int g = 10;
 
  cout << g;
 
  r
```

当然输出的是局部变量的结果10，就像地方法以宪法为标准但是可以增加条件，实现的也就是地方法，比如广东不让摩托车上高速，辽宁就可以。

### 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，那么如果我就不初始化呢，系统会自动初始化为下列值

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

在程序中，局部变量和全局变量的名称可以相同。

但是在函数内的局部变量与全局变量是两个独立的变量，互不影响。

比如

```c++
#include <iostream>
using namespace std;

int main()
{
    int b = 2;
    {
        int b = 1;
        cout << "b = " << b << endl;
    }
    cout << "b = " << b << endl;
}
```

输出的结果

```c++
b = 1
b = 2
```

当变量间出现重名的情况下，作用域小的屏蔽作用域大的，所以上面第一个 cout 输出 b 的值为 1，但由于在块里面申请的变量作用域只限于当前块，所以离开这个块后变量会自动释放，所以第二个 cout 输出 b 的值为 2

# **Day 6 C++常量**

- 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
- 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
- 常量就像是常规的变量，只不过常量的值在定义后不能进行修改

## 整数常量

- 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
- 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意

比如，以下是各种类型的整数常量的实例

```c++
85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
```

## 浮点常量

- 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
- 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的

比如，以下是各种类型的浮点常量的实例

```c++
3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```

## 布尔常量

布尔常量共有两个，它们都是标准的 C++ 关键字：

- **true** 值代表真。
- **false** 值代表假。

我们不应把 true 的值看成 1，把 false 的值看成 0。

## 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义

那么

那么

下表列出了一些这样的转义序列码，详见Day5实例演示一些转义序列字符

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符等=按一下tab键   |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

## 字符串常量

字符串字面值或常量是括在双引号 **""** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用 **\** 做分隔符，把一个很长的字符串常量进行分行，详见Day6实例演示了一些字符串常量

## 定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

### #define 预处理器

下面是使用 #define 预处理器定义常量的形式：

```C++
#define identifier value
```

那么大三上学期我们学到了这个define就是宏定义，详见Day7

### const 关键字

**const**是**constant**的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）

下面是使用const前缀声明指定类型的常量，如下所示

```C++
const type variable = value;
```

**请注意，把常量定义为大写字母形式，例如LENGTH**

定义成 const 后的常量，程序对其中只能读不能修改

```C++
#include "iostream"
using namespace std;
int main()
{
	const double pi=3.141592;//圆周率的值用pi表示
	cout << "圆周率的近似值是" <<endl;
	return 0;
}
```

### 宏定义 #define 和常量 const 的区别

#### **类型和安全检查不同**

宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；

const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查

#### **编译器处理不同**

宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；

const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据

#### **存储方式不同**

宏定义是直接替换，不会分配内存，存储于程序的代码段中；

const常量需要进行内存分配，存储于程序的数据段中

#### **定义域不同**

```C++
void f1()
{
	#define N 12
	const int n 12;
}
void f2()
{
	cout << N << endl; //正确，N已经定义过，不受定义域限制
	cout << N << endl; //错误，n定义域只在f1函数中
}
```

#### **定义后能否取消**

宏定义可以通过#undef来使之前的宏定义失效

const常量定义后将在定义域内永久有效

```c++
void f1()
{
  #define N 12
  const int n = 12;

  #undef N //取消宏定义后，即使在f1函数中，N也无效了
  #define N 21//取消后可以重新定义
}
```

#### **是否可以做函数参数**

宏定义不能作为参数传递给函数

const常量可以在函数的参数列表中出现

# Day 7 C++ 修饰符类型
