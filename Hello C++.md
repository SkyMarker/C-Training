# Day 1 C++简介

支持三种程序设计方式

过程化程序设计、面向对象程序设计、泛型程序设计

## 过程化程序设计

**数据+算法**

明确计算机处理数据的详细过程

用程序设计语言描述处理过程

**缺点**

由于程序规模的扩大，造成程序的混乱难以确保程序的正确性

**结构化程序设计方法**

自顶向下的设计

规定程序结构只能有3种：顺序、分支、循环

## 面向对象程序设计

试图让语言满足问题的要求

设计与问题本质相对应的数据类型

**过程**：设计类——明确表示程序要处理的内容及操作，如：直线、圆、圆片

​		   使用类——设计使用类对象的程序

**优点**

使编程更加方便、**代码重写**

## 泛型程序设计

独立于特定类型的编程

**用途**

提供执行常见任务的通用工具

包括泛型的函数和类

# Day 2 程序生成

## 创建源代码文件

**源代码文件**

也称为源文件，保存程序员写好的程序，源文件的后缀名表明这是一个C++源文件，常用的有cpp

**创建源代码文件**

把写好的程序输入到计算机，并保存成一个文件

## 编译与链接

**从源文件生成可执行文件的过程**

编译：将源文件翻译成机器语言，称目标文件

链接：将目标文件与库文件的目标文件捆绑起来，形成可执行文件

编译链接方式取决于所用的操作系统和编译器

windows + gcc

```shell
gcc prog.cpp
```

PS：跟着打着玩的时候遇到的问题

“error LNK1169: 找到一个或多个多重定义的符号”

A.h中声明了变量a（非类成员)变量），A.cpp是A.h中所声明的类的实现源代码，B.cpp是主程序文件，包含头文件 A.h。编译能够通过这是因为B.cpp包含头文件 A.h后，相当于又定义了变量a。

**解决方法**

是在A.h中的变量声明前加上extern 关键字，表示这里只是声明不定义，然后在A.cpp中不加extern关键字定义这个变量，编译链接顺利通过。

# Day 3 进入C++

## 基本语法

### C++中的分号&语句块

在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

因为C++ 不以行末作为结束符的标识，所以可以在一行上放置多个语句。例如：

```C++
x = y;
y = y+1;
add(x, y);
```

等同于

```C++
x = y; y = y+1; add(x, y);
```

### **C++标识符**

C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内不允许出现标点字符，比如 @、& 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。

### C++关键字

这些保留字不能作为常量名、变量名或其他标识符名称

| asm          | else      | new              | this     |
| ------------ | --------- | ---------------- | -------- |
| auto         | enum      | operator         | throw    |
| bool         | explicit  | private          | true     |
| break        | export    | protected        | try      |
| case         | extern    | public           | typedef  |
| catch        | false     | register         | typeid   |
| char         | float     | reinterpret_cast | typename |
| class        | for       | return           | union    |
| const        | friend    | short            | unsigned |
| const_cast   | goto      | signed           | using    |
| continue     | if        | sizeof           | virtual  |
| default      | inline    | static           | void     |
| delete       | int       | static_cast      | volatile |
| do           | long      | struct           | wchar_t  |
| double       | mutable   | switch           | while    |
| dynamic_cast | namespace | template         |          |

### 三字符组

三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。

三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

| ??=  | #    |
| ---- | ---- |
| ??/  | \    |
| ??'  | ^    |
| ??(  | [    |
| ??)  | ]    |
| ??!  | \|   |
| ??<  | {    |
| ??>  | }    |
| ??-  | ~    |

PS:如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

C++中的空格

只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。

在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```c++
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```c++
fruit = apples + oranges;   // 获取水果的总数
```

## Hello C++

```c++
#include <iostream>//预处理指令
int main()//函数头
{
	using namespace std;	//名字空间声明
	cout << "Come up and C++ me some time.";//显示消息 
	cout << endl;
	cout << "You will not regret it" << endl;
	return 0;//函数结束
}
```

防止窗口闪一下就关闭的代码

```C++
cout << "Press any key to continue." <<endl
cin.get();
```

那么这里看到了

```C++
cin.get();
```

### **读取字符**

一共有三种使用方法

1、用来获取输入的第一个字符

```c++
char ch;
ch = cin.get();//或cin.get(ch);
cout << ch;//若输入abc则输出a
```

2、cin.get(字符数组名,输入字符串的个数)，可以读取空格

```C++
char arr[20];
cin.get(arr,20);
cout << arr;//只会输出19个元素，最后一个为终止符'\0'
```

3、cin.get()用于舍弃输入流的不需要的字符(例如回车)

```C++
char a[10];
char b[10];
cin.get(a,10);
cin.get(b,10);
cout << a << " " << b;
```

cin.get（）是不会舍弃行尾的换行符的
也就是说如果你是输入a后回车在输入b你会发现你不能输入b程序就输出结束了
或者你输入a后空格在输入b，a是从行头开始取，去满在下一个b
这里与cin.getline()不一样，cin.getline(是丢弃行尾的换行符的)
这里就可以用cin.get()还去除换行符

因此上面的代码可以改成

```C++
char a[10];
char b[10];
cin.get(a,10);
cin.get();//去除a输入完毕后的回车
cin.get(b,10);
cout << a << " " << b;
```

同样读取空格等特殊字符的方法也有

```C++
getchar()
```

但是建议使用cin.get()，效率高

那么顺便学一下

### **读取字符数组**

```c++
cin.getline(字符数组，接收个数，结束字符)
```

- 可以接收空格等；
- 结束符可以通过设置第三个参数自己设置，默认是回车

那么再顺便学一下

### **读取String**·

```C++
getline(cin, s);
```

### **预处理指令**

预处理指令以#开头

编译时先处理预处理指令，再进行编译

```C++
#include <iostream>//在此插入文件iosteam的内容
```

iostream被称为头文件或包含文件

### **头文件**

每个头文件支持一组工具

iostream提供输入输出的工具，如用cout输出

C风格或者C++就是风格的头文件后缀为.h

新式风格的头文件不需要后缀

C语言的头文件在文件名前加字母C

## 注释

程序的注释是解释性语句，可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。

C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种

- **//** - 一般用于单行注释。
- /*** ... \*/** - 一般用于多行注释。

C++ 注释以 **/\*** 开始，以 ***/** 终止。例如：

```C++
#include <iostream>
using namespace std;
 
int main() {
    /* 这是注释 */
 
    /* C++ 注释也可以
     * 跨行
     */ 
    cout << "Hello World!";
    return 0;
}
```

在 **/\*** 和 ***/** 注释内部，**//** 字符没有特殊的含义。在 **//** 注释内，**/\*** 和 ***/** 字符也没有特殊的含义。因此，也可以在一种注释内嵌套另一种注释。例如：

```c++
/* 用于输出 Hello World 的注释
 
cout << "Hello World"; // 输出 Hello World
 
*/
```

B!U!T!

块注释符（/*...*/）是不可以嵌套使用的。

**#if 0 ... #endif** 属于条件编译，0 即为参数。

此外，我们还可以使用 **#if 0 ... #endif** 来实现注释，且可以实现嵌套，格式为：

```c++
#if 0
   code
#endif 
```

可以把 **#if 0** 改成 **#if 1** 来执行 **code** 的代码。

这种形式对程序调试也可以帮助，测试时使用 **#if 1** 来执行测试代码，发布后使用 **#if 0** 来屏蔽测试代码。

**#if** 后可以是任意的条件语句。

下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。

```C++
#if condition
  code1
#else
  code2
#endif
```



# Day 4 C++数据类型

## 基本的内置类型

| 布尔型   | bool    |
| -------- | ------- |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

PS:很久很久以前，宽字符型（whcar_t）=unsigned short

注意：不同系统会有所差异，一字节为 8 位

再次注意：默认情况下，int、short、long都是带符号的，即 signed

再再次注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节

| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| ------------------ | ------------- | ------------------------------------------------------------ |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

在项目Day2中可查到如何查看本机的各数据类型占用字节

那么我们学到了endl这个东西

**endl**，这将在每一行后插入一个换行符，

**<<** 运算符用于向屏幕传多个值，

**sizeof()** 运算符用来获取各种数据类型的大小。

## **typedef**声明

那么大三上学期我们学到了这个define

这里也可以用typedef为一个已有的类型取一个新的名字

比如

```C++
typedef int feet;
```

我告诉编译器feet 是 int 的另一个名称

然后

```C++
feet distance;
```

我就创建了一个整形变量distance，(*＞◡❛)

## 枚举类型

枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合

如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"

```c++
enum color { red, green, blue } c;
c = blue;

```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5

```
enum color { red, green=5, blue };
```

在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0

# **Day 5 C++变量**

以下几种为基本变量类型

| bool    | 存储值 true 或 false。                                       |
| ------- | ------------------------------------------------------------ |
| char    | 通常是一个字符（八位）。这是一个整数类型。                   |
| int     | 对机器而言，整数的最自然的大小。                             |
| float   | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double  | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void    | 表示类型的缺失。                                             |
| wchar_t | 宽字符类型。                                                 |

同样，C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等

##  C++中的变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储

![cpp-variable-types-2020-12-14](E:\I really didn't study\C\cpp-variable-types-2020-12-14.png)

变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表

比如

```c++
type variable_list;
```

在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明

```C++
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

BUT

变量只允许定义一次，但可以在多个文件中声明

比如

## C++中的变量声明

声明变量要在头部声明哦~

but它们是在主函数内被定义和初始化的

详见C-Training-Day3

同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行

```C++
// 函数声明
int func();
 
int main()
{
    // 函数调用
    int i = func();
}
 
// 函数定义
int func()
{
    return 0;
}
```

## C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面有两个语句：

```C++
int g = 20;//√
10=20；//×
```

变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。

**自动转换规则：**

- 若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
- 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。   a、若两种类型的字节数不同，转换成字节数高的类型   b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
- 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
- char型和short型参与运算时，必须先转换成int型。
- 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:

```C++
int a=1;
double b=2.5;
a=b;
cout << a; //输出为 2，丢失小数部分
```

```c++
int a = 1;
double b = 2.1;
cout << "a + b = " << a + b << endl;  //输出为a + b = 3.1
```

**强制转换规则：**

强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式）其功能是把表达式的运算结果强制转换成类型说明符所表示的类型

```C++
int a = 1;
double b = 2.1;
cout << "a + b = " << a + (int)b << endl;  //输出为a + b = 3
```











